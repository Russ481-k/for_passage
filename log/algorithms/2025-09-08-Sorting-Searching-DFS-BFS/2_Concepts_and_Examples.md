### 정렬 Sorting

1. 한 줄 Hook — "거의 정렬된 배열, 가장 빨리 끝낼 방법은?"
   느낌: 이럴 땐 삽입 정렬이 의외로 강합니다. 요소가 이미 제자리에 가까우면 이동 비용이 작아요.

- 미니 예시

  - OK: [1,2,3,5,4]에 삽입 정렬 → 4만 한 번 밀면 끝
  - OK: 길이가 작고(≤20) 데이터가 부분 정렬 → 삽입 정렬 고려
  - NG: 이미 정렬인데 퀵소트(고정 피벗) → 최악 O(n^2) 위험

- 대비/함정(내러티브 코멘트 첨부)

  - "안정성이 필요하다면?" → 병합 정렬은 안정적, 퀵은 일반적으로 비안정
  - "메모리 여유가 좁다면?" → 제자리성: 삽입/선택/퀵(일반적 구현) vs 병합은 O(n) 보조메모리
  - "최악을 피하고 싶다면?" → 병합은 항상 O(n log n), 퀵은 피벗 운에 따라 O(n^2)

- 퀵체크(2)

  1. 레코드가 키가 같을 때도 원래 순서를 유지해야 한다면 어떤 정렬을 먼저 떠올릴까요?
  2. 대부분 정렬된 로그 파일에 빠르게 정렬 라벨만 덧붙일 때 적합한 방법은?

- 핵심 요약
  - 한 줄로: 상황 따라 선택. 안정성/메모리/데이터 분포를 먼저 본다.
  - 기억 포인트: "거의 정렬=삽입", "항상 n log n=병합", "평균 빠름=퀵(피벗 품질 중요)".

---

### 탐색 Searching

1. 한 줄 Hook — "정렬 안 된 리스트에 이진 탐색을 쓰면?"
   느낌: 바로 깨집니다. 이진 탐색은 정렬이 전제예요.

- 미니 예시

  - OK: 정렬된 배열에서 타깃 존재 여부 → 이진 탐색 O(log n)
  - OK: 데이터가 작고 정렬 비용이 아깝다 → 선형 탐색 O(n)
  - NG: 해시맵이 있는데도 선형 탐색으로 매번 훑기 → 시간 낭비

- 대비/함정

  - "정렬 vs 미정렬" → 정렬 비용 O(n log n)을 감수할 값이 있는가?
  - "인덱스 접근 가능 여부" → 연결 리스트에서 이진 탐색은 비효율적
  - "중복 처리" → lower_bound/upper_bound 개념으로 첫/마지막 위치 찾기 정리

- 퀵체크(2)

  1. 연결 리스트에서 특정 값 탐색, 어떤 전략이 현실적일까요?
  2. 정렬이 보장된 스트림에서 실시간으로 존재 여부만 확인하면?

- 핵심 요약
  - 한 줄로: 이진 탐색은 정렬과 인덱스 접근이 전제.
  - 기억 포인트: 작은 n은 선형이 단순·안전, 대용량은 정렬+이진 탐색 고려.

---

### 그래프 순회 DFS vs BFS

1. 한 줄 Hook — "최단 경로가 급하면 DFS부터?"
   느낌: 최단 경로엔 BFS가 직관적입니다(무가중치 그래프에서 레벨 순회).

- 미니 예시

  - OK: 무가중치 최단 거리 → BFS(큐)로 레벨별 확장
  - OK: 경로 존재 여부/모든 조합 탐색 → DFS(재귀/스택)
  - NG: 매우 깊은 트리에서 재귀 DFS(스택 오버플로우 위험) → 반복/스택 변환 고려

- 대비/함정

  - "방문 처리 타이밍" → 방문 즉시 표시해 중복 탐색 차단
  - "그래프 표현" → 인접 리스트는 희소 그래프에 유리, 인접 행렬은 밀집에서 단순
  - "큐 vs 스택" → BFS는 큐, DFS는 스택/재귀. 목적에 맞는 자료구조 선택

- 퀵체크(2)

  1. 무가중치 그래프에서 최단 거리를 빠르게 얻고 싶다면?
  2. 퍼즐 백트래킹(예: N-Queen)에는 어떤 순회가 자연스러울까요?

- 핵심 요약
  - 한 줄로: 최단거리=BFS, 완전탐색·백트래킹=DFS.
  - 기억 포인트: 방문 관리와 자료구조 선택이 성능과 정확도를 가른다.
