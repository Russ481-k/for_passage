### 안내

각 문항은 짧게 손으로 시뮬레이션 가능한 수준으로 구성했어요. 코치 멘트를 먼저 읽고, 요구사항을 체크한 뒤 풀이하세요.

---

1. 거의 정렬된 배열 — 삽입 정렬 선택

- 코치 멘트: 경계값! 한두 개만 어긋난 케이스
- 의도: 알고리즘 선택 기준
- 난이도: 쉬움 / 정답 형식: 선택(알고리즘명)
- 문제: [1,2,3,5,4,6,7]을 가장 빠르게 정렬할 1차 선택은?
- 출력 예시: "삽입 정렬"

2. 퀵소트 최악 케이스 직감

- 코치 멘트: 피벗 고정의 함정
- 의도: 평균 vs 최악 비교
- 난이도: 쉬움 / 정답 형식: 설명(한 문장)
- 문제: 이미 정렬된 배열에서 첫 원소를 피벗으로 삼으면 복잡도는?
- 출력 예시: O(n^2)

3. 병합 정렬의 메모리 특성

- 코치 멘트: 안정성/보조메모리
- 의도: 공간 복잡도 이해
- 난이도: 쉬움 / 정답 형식: 선택(True/False)
- 문제: 병합 정렬은 안정적이며 일반적 구현에서 O(n) 추가 메모리를 요구한다.

4. 이진 탐색 전제 조건

- 코치 멘트: 정렬 여부 먼저!
- 의도: 전제조건 점검 습관화
- 난이도: 쉬움 / 정답 형식: 선택(Yes/No)
- 문제: 정렬되지 않은 연결 리스트에 이진 탐색을 바로 적용해도 되는가?

5. lower_bound 사고방식

- 코치 멘트: 중복 처리 패턴
- 의도: 경계 인덱스 찾기
- 난이도: 중간 / 정답 형식: 인덱스 정수
- 문제: 정렬된 배열 [1,2,2,2,3,5]에서 값 2의 첫 위치(0-index)는?

6. BFS로 최단 거리

- 코치 멘트: 레벨별 확장
- 의도: BFS 사용 시기
- 난이도: 중간 / 정답 형식: 경로 길이 정수
- 문제: 무가중치 그래프 1-2-3-4 선형에서 1→4 최단 거리 길이는?

7. DFS 방문 타이밍

- 코치 멘트: 방문 체크 위치
- 의도: 중복 방문 방지
- 난이도: 중간 / 정답 형식: 선택(전/후)
- 문제: DFS에서 방문 배열은 방문하자마자 표시(전) vs 자식 처리 후(후) 중 무엇이 안전한가?

8. 깊은 트리와 재귀 한계

- 코치 멘트: 스택 오버플로우 주의
- 의도: 구현 선택
- 난이도: 중간 / 정답 형식: 선택(반복/재귀)
- 문제: 깊이 10^6 트리 순회에 적합한 DFS 구현은?

9. 탐색 전략 선택

- 코치 멘트: 데이터 크기와 1회성 여부
- 의도: 정렬 비용 vs 질의 수 비교
- 난이도: 중간 / 정답 형식: 설명(한 문장)
- 문제: 미정렬 데이터 10만 건에서 단 한 번만 특정 값 존재 여부 확인. 어떤 전략?

10. 정렬 안정성 필요 여부

- 코치 멘트: 동점 처리 기준
- 의도: 안정 정렬의 의미
- 난이도: 중간 / 정답 형식: 선택(병합/퀵/선택)
- 문제: 같은 키에서 입력 순서 유지가 중요할 때 우선 고려할 정렬은?
