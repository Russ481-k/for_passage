### 해설 읽는 요령

문제를 다시 내 말로 설명 → 한 줄 정답 → 왜 그런지 근거 → 자주 틀리는 포인트 → 확장 예시 순서로 읽어보세요.

---

1. 거의 정렬된 배열 — 삽입 정렬 선택

- 정답: 삽입 정렬
- 근거: 역전(pair inversion)이 적을수록 삽입 정렬의 이동 횟수가 작습니다. 한두 개만 어긋난 경우 평균적으로 매우 빠릅니다.
- 오답 포인트: 무조건 퀵/병합으로 가는 습관
- 확장: 온라인 입력 또는 작은 n 처리에도 유리

2. 퀵소트 최악 케이스 직감

- 정답: O(n^2)
- 근거: 이미 정렬된 배열에서 첫 원소 피벗은 한쪽 분할 쏠림 → 깊이 n 재귀 → 합 O(n^2)
- 오답 포인트: 평균 O(n log n)만 기억
- 확장: 랜덤 피벗/median-of-three로 위험 완화

3. 병합 정렬의 메모리 특성

- 정답: True
- 근거: 병합 과정에서 보조 배열 필요. 또한 병합은 안정적이라 동점 정렬에 유리
- 오답 포인트: 제자리 정렬로 착각
- 확장: 링크드 리스트 병합 정렬은 구조상 공간 이점이 있음

4. 이진 탐색 전제 조건

- 정답: No
- 근거: 정렬과 인덱스 임의 접근이 전제. 연결 리스트에선 인덱스 접근이 느림
- 오답 포인트: 이진 탐색을 만능으로 오해
- 확장: 해시셋/해시맵으로 존재 여부 O(1) 기대값

5. lower_bound 사고방식

- 정답: 1
- 근거: [1,2,2,2,3,5]에서 첫 2의 인덱스는 1
- 오답 포인트: 임의의 2의 위치를 반환
- 확장: upper_bound는 마지막 2의 다음 인덱스(4)

6. BFS로 최단 거리

- 정답: 3
- 근거: 1-2-3-4 선형에서 간선 수가 거리. BFS 레벨 3에서 도달
- 오답 포인트: 노드 수-1 계산을 헷갈림
- 확장: 가중치가 있으면 다익스트라 필요

7. DFS 방문 타이밍

- 정답: 전(방문 즉시 표시)
- 근거: 스택/재귀 중복 진입 방지. 사이클에서 필수
- 오답 포인트: 후처리만으로 충분하다고 착각
- 확장: 위상 정렬의 완성 시간 기록은 후처리 사용

8. 깊은 트리와 재귀 한계

- 정답: 반복(명시적 스택)
- 근거: 재귀 한계와 스택 오버플로우 방지
- 오답 포인트: 무조건 재귀가 간단하다는 편견
- 확장: tail recursion 최적화가 없는 언어 주의

9. 탐색 전략 선택

- 정답: 선형 탐색(또는 해시 구성 여건 시 해시)
- 근거: 1회성 질의에 정렬 O(n log n)을 내기보다 O(n) 선형이 경제적
- 오답 포인트: 이진 탐색을 위해 굳이 정렬부터 수행
- 확장: 다중 질의면 정렬+이진 또는 해시 인덱스 구축

10. 정렬 안정성 필요 여부

- 정답: 병합 정렬
- 근거: 안정 정렬이 기본적으로 보장, 동점 순서 유지
- 오답 포인트: 퀵/선택을 기본값으로 가정
- 확장: 안정 퀵 변형도 가능하지만 구현 복잡

---

### 오답 키워드

- 퀵소트 평균만 기억/최악 O(n^2) 간과
- 이진 탐색 전제(정렬/인덱스 접근) 누락
- DFS 방문 표시 지연으로 중복 방문
- 안정 정렬의 필요 조건 무시

### 1D/3D/7D 복습 체크리스트

- 1D: 정렬 안정성/메모리/복잡도 표를 3분 복기하고, 퀵 최악 예시 상기
- 3D: lower/upper_bound 손 시뮬 2문제, BFS 레벨 개념 재점검
- 7D: 실제 코딩으로 삽입/병합/퀵/이진/DFS/BFS 1회씩 구현, 케이스 비교

### 핵심 요약

- 결국 이렇게 기억: 최단거리=BFS, 백트래킹=DFS, 거의 정렬=삽입, 항상 n log n=병합, 평균 빠름=퀵(피벗 중요), 이진 탐색은 정렬+인덱스 접근이 전제입니다.
